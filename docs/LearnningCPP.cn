2008年 08月 27日 星期三 21:25:39 CST
chapter 1 ~ 2:
    1, print 语句调用str()函数显示对象,而交互式解释器则调用repr()函数来显示对象.
    2, 下划线(_)在解释器中有特别的含义,表示最后一个表达式的值.
    3, >>> 3 < 4 < 5
       True
    4, 请不要将Python的长整数与C语言的长整数混淆.Python的长整数所能表达的范围远远超过C语言的长整数,事实上,Python长整数仅受限于用户计算机的虚拟内存总数.从长远来看,整型与长整型正在逐步统一为一种整数类型.从Python2.3开始,再也不会报整型溢出错误,结果会自动的被转换为长整数.
    5, 字符串有其特有的索引规则:第一个字符的索引是0,最后一个字符的索引是－1.
    6, sqdEvens = [x ** 2 for x in range(8) if not x % 2]
    7, __init__()可以被当成构建函数,不过不象其它语言中的构建函数,它并不创建实例--它仅仅是你的对象创建后执行的第一个方法.
    8, range([[start,]stop[,step]),实际中如何定义optional arguments?

2008年 08月 28日 星期四 09:23:36 CST
chapter 3:
    1, 在使用闭合操作符时,单一语句可以跨多行,例如:在含有小括号,中括号,花括号时可以多行书写.
    2, 在Python语言中,对象是通过引用传递的.在赋值时,不管这个对象是新创建的,还是一个已经存在的,都是将该对象的引用(并不是值)赋值给变量.
    3, Python的赋值语句不会返回值.
    4, x, y = y, x
    5, 􀁺_xxx: 不用'from module import *'导入
        __xxx__: 系统定义名字
􀁺       __xxx: 类中的私有变量名
    6, 如果模块是被导入,__name__的值为模块名字
       如果模块是被直接执行,__name__的值为'__main__'
    7, 当字符串对象"xyz"被创建并赋值给foo时,它的引用计数是1.当增加了一个别名bar时,引用计数变成了2.不过当foo被重新赋值给整数对象123时,xyz 对象的引用计数自动减1,又重新变成了1.

chapter 4:
    1, 因为在Python中类型也是对象,所以type()返回的是对象而不是简单的字符串.
    2, 所有标准对象均可用于布尔测试,同类型的对象之间可以比较大小.每个对象天生具有布尔True或False 值.空对象,值为零的任何数字或者Null对象None的布尔值都是False.
    3, 不同于很多其它语言,多个比较操作可以在同一行上进行,求值顺序为从左到右.
        >>> 4 < 3 < 5 != 2 < 7
    4, Python提供了is和is not运算符来测试两个变量是否指向同一个对象.
    5, 如果是用户自定义对象,cmp()会调用该类的特殊方法__cmp__().
    6, 也就是说repr()输出对Python比较友好,而str()的输出对人比较友好.
    7, Python 2.2统一了类型和类,所有的内建类型现在也都是类,在这基础之上,原来的所谓内建转换函数象int(),type(),list()等等,现在都成了工厂函数.也就是说虽然他们看上去有点象函数,实质上他们是类.当你调用它们时,实际上是生成了该类型的一个实例,就象工厂生产货物一样.

chapter 5:
    1, bool(obj)返回obj对象的布尔值,也就是obj.__nonzero__()方法的返回值.
    2, 没有__nonzero__()方法的对象的默认值是True.

chapter 6:
    1, 所谓浅拷贝就是只拷贝了对对象的索引,而不是重新建立了一个对象!如果你想完全的拷贝一个对象(包括递归,如果你的对象是一个包含在容器中的容器),你需要用到深拷贝,关于浅拷贝和深拷贝的更多信息会在本章的末尾讲到.
    2, print %format:
        %r优先用repr()函数进行字符串转换
        %s优先用str()函数进行字符串转换
        Python2.4里面%u/%o/%x/%X在遇到负数的时候会返回一个有符号字符串.
            注:原因应该是Python的整数没有确定范围,因而不存在负数回绕正数.
    3, 跟C字符串的另一个不同之处是Python的字符串并不是以NUL(\000)作为结束符的.
    4, 对于Python的格式化字符串的操作符,%s把Python字符串中的Unicode对象执行了str(u)操作,所以,输出的应该是u.encode(默认编码).
    5, 列表比较操作有些狡猾,但是合乎逻辑.比较列表时也是用的内建的cmp()函数,基本的比较逻辑是这样的:两个列表的元素分别比较,直到有一方的元素胜出.
    6, 使用extend()方法比连接操作的一个优点是它实际上是把新列表添加到了原有的列表里面,而不是像连接操作那样新建一个列表. list.extend()方法也被用来做复合赋值运算,也就是Python2.0中添加的替换连接操作(+=).
    7, 那些可以改变对象值的可变对象的方法是没有返回值的.
    8, 创建一个元组并给他赋值实际上跟创建一个列表并给它赋值完全一样,除了一点,只有一个元素的元组需要在元组分割符里面加一个逗号(,)用以防止跟普通的分组操作符混淆.不要忘了它是一个工厂方法!
    9, 不可变并不是坏事,比如我们把数据传给一个不了解的API时,可以确保我们的数据不会被修改.
    10, 序列类型对象的浅拷贝是默认类型拷贝,并可以以下几种方式实施:(1)完全切片操作[:],(2)利用工厂函数,比如list(),dict()等,(3)使用copy模块的copy函数.
    11, s = 'hello' 
        s2 = str(s)
        s is s2
        True
        str不是容器,同样的还有int等.

2008年 09月 02日 星期二 16:45:06 CST
chapter 7:
    1, 字典是通过这样的算法来比较的:首先是字典的大小,然后是键,最后是值. 可是,用cmp()做字典的比较一般不是很有用.
    2, 如果dict()输入参数是(另)一个映射对象,比如,一个字典对象,对其调用dict()会从存在的字典里复制内容来生成新的字典. 新生成的字典是原来字典对象的浅复制版本,它与用字典的内建方法copy()生成的字典对象是一样的. 但是从已存在的字典生成新的字典速度比用copy()方法慢,我们推荐使用copy().
    3, update()方法可以用来将一个字典的内容添加到另外一个字典中. 字典中原有的键如果与新添加的键重复,那么重复键所对应的原有条目的值将被新键所对应的值所覆盖. 原来不存在的条目则被添加到字典中.
    4, 所有不可变的类型都是可哈希的,因此它们都可以做为字典的键. 一个要说明的是问题是数字:值相等的数字表示相同的键. 换句话来说,整型数字1和浮点数1.0的哈希值是相同的,即它们是相同的键. 像列表和
字典这样的可变类型,由于它们不是可哈希的,所以不能作为键. 我们知道元组是不可变的,但在小节6.17.2,我们提示过它们也可能不是一成不变的. 用元组做有效的键,必须要加限制:元组中只包括像数字和字符串这样的不可变参数,才可以作为字典中有效的键.

chapter 13: p472 ~ p581
    1, 如果你没有直接或间接的子类化一个对象,那么你就定义了一个经典类.

    1, 即使没有定义属性也可以使用...
        >>> class C:
        ...     pass
        ... 
        >>> c = C()
        >>> c.x = 1
        >>> c.y = 2
        >>> c.x + c.y 
        3
    2, 每个子类最好定义它自己的构造器,不然,基类的构造器会被调用. 然而,如果子类重写基类的构造器,基类的构造器就不会被自动调用了,这样,基类的构造器就必须显式写出才会被执行.
    3, 在Python中,所有的类属性都是公开的,但名字可能被"混淆"了,以阻止未经授权的访问,但仅此而已,再没有其他预防措施了.
    4, 请注意Python并不支持纯虚函数(像C++)或者抽象方法(如在JAVA中),这些都强制程序员在子类中定义方法. 作为替代方法,你可以简单地在基类方法中引发NotImplementedError异常,这样可以获得类似的效果.
    5, 为与OOP惯例保持一致,Python严格要求,没有实例,方法是不能被调用的.
    6, 访问一个类属性的时候,Python解释器将会搜索字典以得到需要的属性. 如果在__dict__中没有找到,将会在基类的字典中进行搜索,采用"深度优先搜索"顺序. 基类集的搜索是按顺序的,从左到右,按其在类定义时,定义父类参数时的顺序.
    7, 调用del x不表示调用了x.__del__(),前面也看到,它仅仅是减少x的引用计数.
    8, Python不仅是动态类型,而且在运行时,允许这些对象属性的动态创建.
        但内建类不可以?
    9, 然而,我们只有当使用类引用version时,才能更新它的值,像上面的C.version递增语句. 如果尝试在实例中设定或更新类属性会创建一个实例属性c.version,后者会阻止对类属性C.versioin的访问,因为第一个访问的就是c.version,这样可以对实例有效地"遮蔽"类属性C.version,直到c.version被清除掉.
    10, 正如上面所看到的那样,使用实例属性来试着修改类属性是很危险的. 原因在于实例拥有它们自已的属性集,在Python中没有明确的方法来指示你想要修改同名的类属性,比如,没有global关键字可以用来在一个函数中设置一个全局变量(来代替同名的局部变量). 修改类属性需要使用类名,而不是实例名.
    11, staticmethod/classmethod()/@staticmethod/@classmethod
    12, 需要注意的是文档字符串对类,函数/方法,还有模块来说都是唯一的,所以特殊属性__doc__不会从基类中继承过来.
    13, super(C, self).foo()
        如果存在多重继承,super()如何确定?
    14, 注意,所有的__new()__方法都是类方法,我们要显式传入类传为第一个参数,这类似于常见的方法如__init__()中需要的self.
